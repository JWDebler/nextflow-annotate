#!/usr/bin/env nextflow

params.genomes = 'data/**/tmp.fasta'
genomes = Channel.fromPath(params.genomes)


def toFasta(defLine, sequence, width=80) {
    return (">" + defLine + "\n" + wrapString(sequence, width) + "\n")
}

def wrapString(text, width=80) {
  def out = []
  while(text.length() > width) {
    out += text[0..(width-1)]
    text = text[width..-1]
  }
  out += text
  return out.join("\n")
}

process cleanGenome {
        input:
        val genome from genomes

        output:
        set name, stdout into cleanGenomes
        
        script:
        name = genome.getParent().getBaseName()
        """
        awk '/^>/ && !/[.*]/ {print(\$0, "[$name]")} /^>/ && /[.*]/ {print \$0} /^[^>]/ {print(toupper(\$0))}' '$genome'
        sed -ie "s/\015//" '$genome'
        """
}

process RepeatMasker {
        container 'repeatmasker'
        
        input:
        set name, 'genome' from cleanGenomes

        output:
        set name, 'genome.masked' into maskedGenomes
        
        """
        RepeatMasker $genome
        """
}

process getorf {
        container 'robsyme/emboss'

        input:
        set name, 'maskedGenome' from maskedGenomes

        output:
        file 'orfs.aa.fasta' into orfFiles

        """
        getorf -sequence $maskedGenome -outseq orfs.aa.fasta -minsize 150 -find 1
        """
}

cleanOrfs = orfFiles.splitFasta(record: [header: true, seqString: true])
        .filter { record ->
             xCount = record.seqString.count('X')
             length = record.seqString.size()
             xCount / length < 0.3
        }
        .map { record ->
             record.seqString = record.seqString.replaceAll('X','')
             return toFasta(record.header, record.seqString)
        }

process hhblit {
        container 'robsyme/hhblits'

        input:
        file 'orf.fasta' from cleanOrfs

        output:
        stdout into hhblitOutput

        """
        #hhblits -i orf.fasta -d /databases/transposons -maxmem 5 -cpu 1 -o stdout -e 1E-5 -E 1E-5 -id 80 -p 80 -z 0 -b 0 -B 3 -Z 3 -n 1 -mact 0.5 -v 0
        hhblits -i orf.fasta -d /databases/transposons -n 1 -o stdout
        """
}

process parse_hhr {
        input:
        val result from hhblitOutput

        exec:
        (fullMatch, queryName, queryStart, queryEnd, revString, strain) = (result =~ (/Query\s+(\S+) \[(\d+) - (\d+)\] (\(REVERSE SENSE\))?.* \[(.*)\]/))[0]
        println fullMatch
}
